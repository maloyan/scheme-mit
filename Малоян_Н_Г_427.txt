#lang scheme/base
(require racket/trace)

(define (funI lst)
  (if (null? lst)
      '()
      ;cur - текущее значение
      ;max - максимальное значение
      ;ans - список с ответом
      ;pos - позиция текущего элемента
      (foldl (λ(cur ans max pos) (cond ((= cur max) (cons pos ans))
                                       ((> cur max) ()))))))
(funI '( -1 0 1 -1 0 1 -1)) ;=>(2 5)
(funI '())                  ;=>()
(funI '(1 1 1 1))           ;=>(0 1 2 3)
(funI '(1 2 3 4))           ;=>(3)
(funI '(4 3 2 1))           ;=>(0)
(funI '(1 2 4 3))           ;=>(2)
(funI '(-4 -3 -2 -1))       ;=>(3)
(funI '(-5))                ;=>(0)

(define (taskIIa n)
  (define (find n m)
    (if (= m n)
        n
        (if (integer? (/ n m))
            m
            (find n (+ m 1)))))
  (if (= n 1)
      '()
      (let ((num (find n 2)))
        (cons num (taskIIa (/ n num)))))
  )
;(taskIIa 13)

(define (taskIIb n)
  (define (helper n cur last ans)
    (if (= n 1)
        ans
        (if (integer? (/ n cur))
            (helper (/ n cur) 2
                    (if (> cur last)
                        cur
                        last)
                    (if (> cur last)
                        (cons cur ans)
                        ans))
            (helper n (+ cur 1) last ans))))
  (helper n 2 0 '()))
;(taskIIb 3)

;Находит составляющие из чисел фиббоначи и записывает в лист ()
(define (taskIIIlst n)
  (define (fiblst fib n)
    (let ((cur(+ (car fib) (cadr fib))))
      (if (<= n cur)
          fib
          (fiblst (cons cur fib) n ))))
  (if (< n 3) 
      (if (= n 1) '(1) '(2 1))
      (let* ((fiblst (fiblst '(2 1) n))
            (first (car fiblst)))
        (cons first (taskIIIlst (- n first))))))
;(trace taskIII)
;(taskIII 9)

; Идея в том, чтобы составить убывающий список фибоначчи, который начинается с элемента, который меньше n.
; Затем мы берем, а затем вычитаем из n первый элемент этого листа, потом находим в листе элемент < (n - first) и берем его итд
(define (taskIIIa n)
  (define (fiblst fib n)
    (let ((cur(+ (car fib) (cadr fib))))
      (if (<= n cur)
          fib
          (fiblst (cons cur fib) n ))))
  (let ((fiblst (fiblst '(2 1) n)))
    (foldl (λ (x y) (if (< x n)
                        (begin (set! n (- n x)) (+ 1 (* y 2)))
                        (* y 2))) 0 fiblst)))
;(trace taskIIIa)
;(taskIIIa 8)